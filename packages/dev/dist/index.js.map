{"version":3,"sources":["../src/directory.ts","../src/eslint.ts","../src/file.ts","../src/block.ts","../src/json.ts","../src/project.ts","../src/projectScript.ts"],"names":["ESLintConfig","exists","access","constants","existsSync","rm","rmSync","Project"],"mappings":"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","file":"index.js","sourcesContent":["import { existsSync, mkdirSync, rmSync } from 'node:fs';\nimport { access, constants, mkdir, rm } from 'node:fs/promises';\n\nasync function exists(path: string) {\n  try {\n    await access(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface DirectoryOptions {\n  /**\n   * Directory path\n   */\n  readonly path: string;\n  /**\n   * Directory target state\n   */\n  readonly state: 'present' | 'absent';\n}\n\n/**\n * Ensure directory is present/absent\n *\n * @example\n * ```ts\n * await directory({\n *   path: 'foo/bar',\n *   state: 'present',\n * })\n * ```\n *\n * @param options\n */\nexport async function directory(options: DirectoryOptions): Promise<void> {\n  const { path, state } = options;\n  const isPresent = await exists(path);\n  if (state === 'present') {\n    if (!isPresent) {\n      await mkdir(path, { recursive: true });\n    }\n  } else if (isPresent) {\n    await rm(path, { recursive: true });\n  }\n}\n\n/**\n * Ensure directory is present/absent\n *\n * @example\n * ```ts\n * await directorySync({\n *   path: 'foo/bar',\n *   state: 'present',\n * })\n * ```\n *\n * @param options\n */\nexport function directorySync(options: DirectoryOptions): void {\n  const { path, state } = options;\n  const isPresent = existsSync(path);\n  if (state === 'present') {\n    if (!isPresent) {\n      mkdirSync(path, { recursive: true });\n    }\n  } else if (isPresent) {\n    rmSync(path, { recursive: true });\n  }\n}\n","import type { ESLint, Linter } from 'eslint';\n\nfunction toArray<T>(value: T[] | T | undefined): T[] {\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nfunction concatArray<T>(left: T[] | T | undefined, right: T[] | T | undefined): T[] {\n  return toArray(left).concat(toArray(right));\n}\n\nexport namespace ESLintConfig {\n  /**\n   *\n   * @param configs\n   */\n  export function concat(...configs: ESLint.ConfigData[]): ESLint.ConfigData {\n    return configs.reduce(\n      (returnValue, config) => ({\n        ...returnValue,\n        ...config,\n        env: { ...returnValue.env, ...config.env },\n        extends: concatArray(returnValue.extends, config.extends),\n        globals: { ...returnValue.globals, ...config.globals },\n        overrides: concatArray(returnValue.overrides, config.overrides),\n        parserOptions: { ...returnValue.parserOptions, ...config.parserOptions },\n        plugins: concatArray(returnValue.plugins, config.plugins),\n        rules: { ...returnValue.rules, ...config.rules },\n        settings: { ...returnValue.settings, ...config.settings },\n      }),\n      {\n        env: {},\n        extends: [],\n        globals: {},\n        overrides: [],\n        parserOptions: {},\n        plugins: [],\n        rules: {},\n        settings: {},\n      },\n    );\n  }\n\n  /**\n   * Always return 'off'. `_status` is the previous rule value.\n   *\n   * @param _status\n   */\n  export function fixme(_status: Linter.RuleLevel | [Linter.RuleLevel, ...any[]] | undefined) {\n    return 'off' as const;\n  }\n}\n","import { readFile, rm, writeFile, access } from 'node:fs/promises';\nimport { accessSync, constants, readFileSync, rmSync, writeFileSync } from 'node:fs';\n\nasync function exists(path: string) {\n  try {\n    await access(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction existsSync(path: string) {\n  try {\n    accessSync(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface FileOptions {\n  /**\n   * File path\n   */\n  readonly path: string;\n  /**\n   * File target state\n   */\n  readonly state: 'present' | 'absent';\n  /**\n   * File content mapping function\n   *\n   * @param content\n   */\n  readonly update?: ((content: string) => string | undefined) | undefined;\n  /**\n   * File encoding\n   */\n  readonly encoding?: BufferEncoding;\n}\n\n/**\n * Ensure file is present/absent with content initialized or modified with `update\n *\n * @example\n * ```ts\n * await file({\n *   path: 'foo/bar',\n *   state: 'present',\n *   update: (content) => content + '_test', // This will append '_test' after current content\n * })\n * ```\n *\n * @param options\n */\nexport async function file(options: FileOptions): Promise<void> {\n  const { path, state, update, encoding = 'utf8' } = options;\n  if (state === 'present') {\n    const isPresent = await exists(path);\n    const previousContent = isPresent ? await readFile(path, encoding) : '';\n    const newContent = update == null ? '' : update(previousContent);\n    if (newContent != null) {\n      await writeFile(path, newContent, encoding);\n    }\n  } else {\n    await rm(path, { force: true });\n  }\n}\n\n/**\n * Ensure file is present/absent with content initialized or modified with `update\n *\n * @example\n * ```ts\n * fileSync({\n *   path: 'foo/bar',\n *   state: 'present',\n *   update: (content) => content + '_test', // This will append '_test' after current content\n * })\n * ```\n *\n * @param options\n */\nexport function fileSync(options: FileOptions): void {\n  const { path, state, update, encoding = 'utf8' } = options;\n  if (state === 'present') {\n    const isPresent = existsSync(path);\n    const previousContent = isPresent ? readFileSync(path, encoding) : '';\n    const newContent = update == null ? '' : update(previousContent);\n    if (newContent != null) {\n      writeFileSync(path, newContent, encoding);\n    }\n  } else {\n    rmSync(path, { force: true });\n  }\n}\n","import { type FileOptions, file, fileSync } from './file.js';\n\nexport interface BlockOptions {\n  /**\n   * The marker builder function that will take either `markerBegin` or `markerEnd`\n   *\n   * @default '# ${mark} MANAGED BLOCK'\n   */\n  marker?: (mark: 'Begin' | 'End') => string;\n  /**\n   * File path\n   */\n  path: string;\n  /**\n   * Block content to insert\n   */\n  block: string;\n  /**\n   * Insert position\n   */\n  insertPosition?: ['before', 'BeginningOfFile' | RegExp] | ['after', 'EndOfFile' | RegExp];\n  /**\n   * Block target state\n   */\n  state?: 'present' | 'absent';\n}\n\nconst EOF = 'EndOfFile';\nconst BOF = 'BeginningOfFile';\nconst insertAt = (str: string, index: number, toInsert: string) => str.slice(0, index) + toInsert + str.slice(index);\nconst matchLast = (string: string, regexp: RegExp) => {\n  const matcher = new RegExp(regexp.source, `${regexp.flags}g`);\n  let firstIndex = -1;\n  let lastIndex = -1;\n  let matches;\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition\n  while (true) {\n    matches = matcher.exec(string);\n    if (matches == null) {\n      break;\n    }\n    firstIndex = matches.index;\n    lastIndex = matcher.lastIndex;\n  }\n  return { firstIndex, lastIndex };\n};\n\nfunction toFileOptions(options: BlockOptions): FileOptions {\n  const {\n    marker = (mark) => `# ${mark.toUpperCase()} MANAGED BLOCK`,\n    path,\n    block: blockName,\n    insertPosition = ['after', EOF],\n    state = 'present',\n  } = options;\n\n  const EOL = '\\n';\n  const beginBlock = marker('Begin');\n  const endBlock = marker('End');\n\n  /**\n   * @param content\n   */\n  function findBlock(content: string) {\n    const startIndex = content.indexOf(beginBlock);\n    const endIndex = content.indexOf(endBlock) + endBlock.length;\n\n    return {\n      endIndex,\n      exists: startIndex !== -1 && endIndex >= 0,\n      startIndex,\n    };\n  }\n\n  function apply(fullContent: string, blockContent: string) {\n    const found = findBlock(fullContent);\n    const remove = state === 'absent';\n    const replaceBlock = remove ? '' : beginBlock + EOL + blockContent + EOL + endBlock;\n    const [positionDirection, positionAnchor] = insertPosition;\n\n    if (found.exists) {\n      return fullContent.slice(0, found.startIndex) + replaceBlock + fullContent.slice(found.endIndex);\n    }\n    if (remove) {\n      return fullContent;\n    }\n    switch (positionDirection) {\n      case 'before': {\n        if (positionAnchor !== BOF) {\n          const { firstIndex } = matchLast(fullContent, positionAnchor);\n          if (firstIndex >= 0) {\n            return insertAt(fullContent, firstIndex, replaceBlock + EOL);\n          }\n        }\n\n        // Beginning of file\n        return replaceBlock + EOL + fullContent;\n      }\n      case 'after': {\n        // insert\n        if (positionAnchor !== EOF) {\n          const { lastIndex } = matchLast(fullContent, positionAnchor);\n          if (lastIndex >= 0) {\n            return insertAt(fullContent, lastIndex, EOL + replaceBlock);\n          }\n        }\n\n        // end of file\n        return fullContent + EOL + replaceBlock;\n      }\n\n      default: {\n        throw new Error(`Unsupported position ${String(positionDirection)}`);\n      }\n    }\n  }\n\n  return {\n    path,\n    state: 'present',\n    update: (sourceContent) => apply(sourceContent, blockName),\n  };\n}\n\n/**\n * Replace asynchronously a block in file that follows pattern :\n *\n * marker(markerBegin)\n * ...\n * marker(markerEnd)\n *\n * @param options\n */\nexport function block(options: BlockOptions) {\n  return file(toFileOptions(options));\n}\n\n/**\n * Replace synchronously a block in file that follows pattern :\n *\n * marker(markerBegin)\n * ...\n * marker(markerEnd)\n *\n * @param options\n */\nexport function blockSync(options: BlockOptions) {\n  return fileSync(toFileOptions(options));\n}\n","import { type FileOptions, file, fileSync } from './file.js';\n\nexport type JSONValue = null | number | string | boolean | JSONValue[] | { [key: string]: JSONValue };\n\nexport interface JSONOption<V = JSONValue> {\n  /**\n   * File path\n   */\n  readonly path: string;\n  /**\n   * File target state\n   */\n  readonly state: 'present' | 'absent';\n  /**\n   * File content mapping function\n   *\n   * @param content\n   */\n  readonly update?: ((content: V | undefined) => V | undefined) | undefined;\n  /**\n   * File encoding\n   */\n  readonly encoding?: BufferEncoding;\n}\n\nfunction toFileOption<Value>({ update, ...otherOptions }: JSONOption<Value>): FileOptions {\n  return {\n    ...otherOptions,\n\n    update:\n      update == null\n        ? update\n        : (content) => {\n            const jsonValue = content === '' ? undefined : (JSON.parse(content) as Value);\n\n            return JSON.stringify(update(jsonValue));\n          },\n  };\n}\n\n/**\n * Ensure file is present/absent asynchronously with content value initialized or modified with `update`\n *\n * @param options\n */\nexport async function json<Value>(options: JSONOption<Value>): Promise<void> {\n  return file(toFileOption(options));\n}\n\n/**\n * Ensure file is present/absent synchronously with content value initialized or modified with `update`\n *\n * @param options\n */\nexport function jsonSync<Value>(options: JSONOption<Value>): void {\n  return fileSync(toFileOption(options));\n}\n","function escapeRegExp(value: string) {\n  // eslint-disable-next-line unicorn/prefer-string-raw\n  return value.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nexport namespace Project {\n  /**\n   * A type of a file extension\n   */\n  export type Extension = `.${string}`;\n\n  /**\n   * Object hash of all well-known file extension category to file extensions mapping\n   */\n  export interface ExtensionRegistry {\n    graphql: readonly Extension[];\n    jpeg: readonly Extension[];\n    javascript: readonly Extension[];\n    javascriptreact: readonly Extension[];\n    typescript: readonly Extension[];\n    typescriptreact: readonly Extension[];\n    yaml: readonly Extension[];\n  }\n\n  /**\n   * A list of \"vscode-like\" language identifiers (i.e. \"javascript\", \"javascriptreact\")\n   */\n  export type LanguageId = keyof ExtensionRegistry;\n\n  /**\n   * Supported ECMA version\n   *\n   * @example\n   * ```ts\n   * Project.ecmaVersion() // 2022\n   * ```\n   */\n  export function ecmaVersion() {\n    return 2022 as const;\n  }\n\n  const registry: ExtensionRegistry = {\n    graphql: ['.gql', '.graphql'],\n    jpeg: ['.jpg', '.jpeg'],\n    javascript: ['.js', '.cjs', '.mjs'],\n    javascriptreact: ['.jsx'],\n    typescript: ['.ts', '.cts', '.mts'],\n    typescriptreact: ['.tsx'],\n    yaml: ['.yaml', '.yml'],\n  };\n\n  /**\n   * Return a list of extensions\n   *\n   * @example\n   * ```ts\n   * Project.queryExtensions(['javascript']); // ['.js', '.cjs', ...]\n   * Project.queryExtensions(['typescript', 'typescriptreact']); // ['.ts', '.mts', ..., '.tsx']\n   * ```\n   *\n   * @param languages\n   */\n  export function queryExtensions(languages: LanguageId[]): readonly Extension[] {\n    return languages\n      .reduce<Extension[]>(\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        (previousValue, currentValue) => previousValue.concat(registry[currentValue] ?? ([] as Extension[])),\n        [],\n      )\n      .sort();\n  }\n\n  /**\n   * Supported file extensions\n   *\n   * @example\n   * ```ts\n   * Project.sourceExtensions() // ['.ts', '.js', ...]\n   * ```\n   */\n  export function sourceExtensions() {\n    return queryExtensions(['javascript', 'javascriptreact', 'typescript', 'typescriptreact']);\n  }\n\n  const RESOURCE_EXTENSIONS: readonly Extension[] = Object.freeze([\n    '.css',\n    '.sass',\n    '.scss',\n    '.less',\n    '.gif',\n    '.png',\n    '.svg',\n    ...queryExtensions(['graphql', 'jpeg', 'yaml']),\n  ]);\n\n  /**\n   * Resource file extensions\n   *\n   * @example\n   * ```ts\n   * Project.resourceExtensions() // ['.css', '.sass', ...]\n   * ```\n   */\n  export function resourceExtensions() {\n    return RESOURCE_EXTENSIONS;\n  }\n\n  const IGNORED = Object.freeze([\n    'node_modules/',\n    'build/',\n    'cjs/',\n    'coverage/',\n    'dist/',\n    'dts/',\n    'esm/',\n    'lib/',\n    'mjs/',\n    'umd/',\n  ]);\n\n  /**\n   * Files and folders to always ignore\n   *\n   * @example\n   * ```ts\n   * IGNORED // ['node_modules/', 'build/', ...]\n   * ```\n   */\n  export function ignored() {\n    return IGNORED;\n  }\n\n  /**\n   * Return a RegExp that will match any list of extensions\n   *\n   * @example\n   * ```ts\n   * Project.extensionsToMatcher(['.js', '.ts']) // RegExp = /(\\.js|\\.ts)$/\n   * ```\n   */\n  export function extensionsToMatcher(extensions: readonly Extension[]): RegExp {\n    return new RegExp(`(${extensions.map(escapeRegExp).join('|')})$`);\n  }\n\n  /**\n   * Return a glob matcher that will match any list of extensions\n   *\n   * @example\n   * ```ts\n   * Project.extensionsToGlob(['.js', '.ts']) // '*.+(js|ts)'\n   * ```\n   */\n  export function extensionsToGlob(extensions: readonly Extension[]): string {\n    return `*.+(${extensions.map((_) => _.replace(/^\\./, '')).join('|')})`;\n  }\n}\n","/**\n * Project common scripts\n */\nexport const ProjectScript = {\n  Build: 'build',\n  Clean: 'clean',\n  CodeAnalysis: 'code-analysis',\n  Coverage: 'coverage',\n  Develop: 'develop',\n  Docs: 'docs',\n  Format: 'format',\n  Install: 'install',\n  Lint: 'lint',\n  Prepare: 'prepare',\n  Release: 'release',\n  Rescue: 'rescue',\n  Spellcheck: 'spellcheck',\n  Test: 'test',\n  Validate: 'validate',\n} as const;\nexport type ProjectScript = (typeof ProjectScript)[keyof typeof ProjectScript];\n"]}