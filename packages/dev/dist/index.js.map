{"version":3,"file":"index.js","names":["exists","constants","existsSync","registry: ExtensionRegistry","RESOURCE_EXTENSIONS: readonly Extension[]"],"sources":["../src/directory.ts","../src/ESLintConfig.ts","../src/file.ts","../src/block.ts","../src/interopDefault.ts","../src/json.ts","../src/Project.ts","../src/ProjectScript.ts","../src/exec.ts","../src/yarnConfig.ts","../src/yarnVersion.ts"],"sourcesContent":["import { existsSync, mkdirSync, rmSync } from 'node:fs';\nimport { access, constants, mkdir, rm } from 'node:fs/promises';\n\nasync function exists(path: string) {\n  try {\n    await access(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface DirectoryOptions {\n  /**\n   * Directory path\n   */\n  readonly path: string;\n  /**\n   * Directory target state\n   */\n  readonly state: 'present' | 'absent';\n}\n\n/**\n * Ensure directory is present/absent\n *\n * @example\n * ```ts\n * await directory({\n *   path: 'foo/bar',\n *   state: 'present',\n * })\n * ```\n *\n * @param options\n */\nexport async function directory(options: DirectoryOptions): Promise<void> {\n  const { path, state } = options;\n  const isPresent = await exists(path);\n  if (state === 'present') {\n    if (!isPresent) {\n      await mkdir(path, { recursive: true });\n    }\n  } else if (isPresent) {\n    await rm(path, { recursive: true });\n  }\n}\n\n/**\n * Ensure directory is present/absent\n *\n * @example\n * ```ts\n * await directorySync({\n *   path: 'foo/bar',\n *   state: 'present',\n * })\n * ```\n *\n * @param options\n */\nexport function directorySync(options: DirectoryOptions): void {\n  const { path, state } = options;\n  const isPresent = existsSync(path);\n  if (state === 'present') {\n    if (!isPresent) {\n      mkdirSync(path, { recursive: true });\n    }\n  } else if (isPresent) {\n    rmSync(path, { recursive: true });\n  }\n}\n","import type { ESLint } from 'eslint';\n\nfunction toArray<T>(value: T[] | T | undefined): T[] {\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nfunction concatArray<T>(left: T[] | T | undefined, right: T[] | T | undefined): T[] {\n  return [...toArray(left), ...toArray(right)];\n}\n\nexport namespace ESLintConfig {\n  /**\n   *\n   * @param configs\n   */\n  export function concat(...configs: ESLint.ConfigData[]): ESLint.ConfigData {\n    return configs.reduce(\n      (returnValue, config) => ({\n        ...returnValue,\n        ...config,\n        env: { ...returnValue.env, ...config.env },\n        extends: concatArray(returnValue.extends, config.extends),\n        globals: { ...returnValue.globals, ...config.globals },\n        overrides: concatArray(returnValue.overrides, config.overrides),\n        parserOptions: { ...returnValue.parserOptions, ...config.parserOptions },\n        plugins: concatArray(returnValue.plugins, config.plugins),\n        rules: { ...returnValue.rules, ...config.rules },\n        settings: { ...returnValue.settings, ...config.settings },\n      }),\n      {\n        env: {},\n        extends: [],\n        globals: {},\n        overrides: [],\n        parserOptions: {},\n        plugins: [],\n        rules: {},\n        settings: {},\n      },\n    );\n  }\n\n  /**\n   * Always return 'off'. `_status` is the previous rule value.\n   *\n   * @param _status\n   */\n  export function fixme(_status: string | number | [string | number, ...any[]] | undefined) {\n    return 'off' as const;\n  }\n\n  /**\n   * Renames rules in the given object according to the given map.\n   *\n   * Given a map `{ 'old-prefix': 'new-prefix' }`, and a rule object\n   * `{ 'old-prefix/rule-name': 'error' }`, this function will return\n   * `{ 'new-prefix/rule-name': 'error' }`.\n   *\n   * @param rules - The object containing the rules to rename.\n   * @param map - The object containing the rename map.\n   * @returns The object with the renamed rules.\n   */\n  export function renameRules(rules: Record<string, any>, map: Record<string, string>): Record<string, any> {\n    return Object.fromEntries(\n      Object.entries(rules).map(([key, value]) => {\n        for (const [from, to] of Object.entries(map)) {\n          if (key.startsWith(`${from}/`)) return [to + key.slice(from.length), value];\n          else if (from === '' && !key.includes('/') && to !== '') return [to + key, value];\n        }\n        return [key, value];\n      }),\n    );\n  }\n}\n","import { readFile, rm, writeFile, access } from 'node:fs/promises';\nimport { accessSync, constants, readFileSync, rmSync, writeFileSync } from 'node:fs';\n\nasync function exists(path: string) {\n  try {\n    await access(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction existsSync(path: string) {\n  try {\n    accessSync(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface FileOptions {\n  /**\n   * File path\n   */\n  readonly path: string;\n  /**\n   * File target state\n   */\n  readonly state: 'present' | 'absent';\n  /**\n   * File content mapping function\n   *\n   * @param content\n   */\n  readonly update?: ((content: string) => string | undefined) | undefined;\n  /**\n   * File encoding\n   */\n  readonly encoding?: BufferEncoding;\n}\n\n/**\n * Ensure file is present/absent with content initialized or modified with `update\n *\n * @example\n * ```ts\n * await file({\n *   path: 'foo/bar',\n *   state: 'present',\n *   update: (content) => content + '_test', // This will append '_test' after current content\n * })\n * ```\n *\n * @param options\n */\nexport async function file(options: FileOptions): Promise<void> {\n  const { path, state, update, encoding = 'utf8' } = options;\n  if (state === 'present') {\n    const isPresent = await exists(path);\n    const previousContent = isPresent ? await readFile(path, encoding) : '';\n    const newContent = update == null ? '' : update(previousContent);\n    if (newContent != null) {\n      await writeFile(path, newContent, encoding);\n    }\n  } else {\n    await rm(path, { force: true });\n  }\n}\n\n/**\n * Ensure file is present/absent with content initialized or modified with `update\n *\n * @example\n * ```ts\n * fileSync({\n *   path: 'foo/bar',\n *   state: 'present',\n *   update: (content) => content + '_test', // This will append '_test' after current content\n * })\n * ```\n *\n * @param options\n */\nexport function fileSync(options: FileOptions): void {\n  const { path, state, update, encoding = 'utf8' } = options;\n  if (state === 'present') {\n    const isPresent = existsSync(path);\n    const previousContent = isPresent ? readFileSync(path, encoding) : '';\n    const newContent = update == null ? '' : update(previousContent);\n    if (newContent != null) {\n      writeFileSync(path, newContent, encoding);\n    }\n  } else {\n    rmSync(path, { force: true });\n  }\n}\n","import { type FileOptions, file, fileSync } from './file.js';\n\nexport interface BlockOptions {\n  /**\n   * The marker builder function that will take either `markerBegin` or `markerEnd`\n   *\n   * @default '# ${mark} MANAGED BLOCK'\n   */\n  marker?: (mark: 'Begin' | 'End') => string;\n  /**\n   * File path\n   */\n  path: string;\n  /**\n   * Block content to insert\n   */\n  block: string;\n  /**\n   * Insert position\n   */\n  insertPosition?: ['before', 'BeginningOfFile' | RegExp] | ['after', 'EndOfFile' | RegExp];\n  /**\n   * Block target state\n   */\n  state?: 'present' | 'absent';\n}\n\nconst EOF = 'EndOfFile';\nconst BOF = 'BeginningOfFile';\nconst insertAt = (str: string, index: number, toInsert: string) => str.slice(0, index) + toInsert + str.slice(index);\nconst matchLast = (string: string, regexp: RegExp) => {\n  const matcher = new RegExp(regexp.source, `${regexp.flags}g`);\n  let firstIndex = -1;\n  let lastIndex = -1;\n  let matches;\n\n  while (true) {\n    matches = matcher.exec(string);\n    if (matches == null) {\n      break;\n    }\n    firstIndex = matches.index;\n    lastIndex = matcher.lastIndex;\n  }\n  return { firstIndex, lastIndex };\n};\n\nfunction toFileOptions(options: BlockOptions): FileOptions {\n  const {\n    marker = (mark) => `# ${mark.toUpperCase()} MANAGED BLOCK`,\n    path,\n    block: blockName,\n    insertPosition = ['after', EOF],\n    state = 'present',\n  } = options;\n\n  const EOL = '\\n';\n  const beginBlock = marker('Begin');\n  const endBlock = marker('End');\n\n  /**\n   * @param content\n   */\n  function findBlock(content: string) {\n    const startIndex = content.indexOf(beginBlock);\n    const endIndex = content.indexOf(endBlock) + endBlock.length;\n\n    return {\n      endIndex,\n      exists: startIndex !== -1 && endIndex >= 0,\n      startIndex,\n    };\n  }\n\n  function apply(fullContent: string, blockContent: string) {\n    const found = findBlock(fullContent);\n    const remove = state === 'absent';\n    const replaceBlock = remove ? '' : beginBlock + EOL + blockContent + EOL + endBlock;\n    const [positionDirection, positionAnchor] = insertPosition;\n\n    if (found.exists) {\n      return fullContent.slice(0, found.startIndex) + replaceBlock + fullContent.slice(found.endIndex);\n    }\n    if (remove) {\n      return fullContent;\n    }\n    switch (positionDirection) {\n      case 'before': {\n        if (positionAnchor !== BOF) {\n          const { firstIndex } = matchLast(fullContent, positionAnchor);\n          if (firstIndex >= 0) {\n            return insertAt(fullContent, firstIndex, replaceBlock + EOL);\n          }\n        }\n\n        // Beginning of file\n        return replaceBlock + EOL + fullContent;\n      }\n      case 'after': {\n        // insert\n        if (positionAnchor !== EOF) {\n          const { lastIndex } = matchLast(fullContent, positionAnchor);\n          if (lastIndex >= 0) {\n            return insertAt(fullContent, lastIndex, EOL + replaceBlock);\n          }\n        }\n\n        // end of file\n        return fullContent + EOL + replaceBlock;\n      }\n\n      default: {\n        throw new Error(`Unsupported position ${String(positionDirection)}`);\n      }\n    }\n  }\n\n  return {\n    path,\n    state: 'present',\n    update: (sourceContent) => apply(sourceContent, blockName),\n  };\n}\n\n/**\n * Replace asynchronously a block in file that follows pattern :\n *\n * marker(markerBegin)\n * ...\n * marker(markerEnd)\n *\n * @param options\n */\nexport function block(options: BlockOptions) {\n  return file(toFileOptions(options));\n}\n\n/**\n * Replace synchronously a block in file that follows pattern :\n *\n * marker(markerBegin)\n * ...\n * marker(markerEnd)\n *\n * @param options\n */\nexport function blockSync(options: BlockOptions) {\n  return fileSync(toFileOptions(options));\n}\n","const getDefaultOrElse = (_: any) => _?.default ?? _;\n/**\n * Resolves a module or promise-like object, returning the default export if available.\n *\n * @example\n * ```ts\n * // modules.ts\n * export default {\n *   foo: true\n * };\n * // Async API\n * const modPromise = import('./module');\n * interopDefault(modPromise); // == Promise.resolve({ foo: true })\n * // Sync API\n * const mod = await import('./module');\n * interopDefault(mod); // == { foo: true }\n * ```\n *\n * @template T - The type of the module or promise-like object.\n * @param m - The module or promise-like object to resolve.\n * @returns A promise resolving to the default export if present, otherwise the module itself.\n */\nexport function interopDefault<T>(m: PromiseLike<T>): Promise<T extends { default: infer U } ? U : T>;\nexport function interopDefault<T>(m: T): T extends { default: infer U } ? U : T;\nexport function interopDefault<T>(m: T | PromiseLike<T>): Promise<T extends { default: infer U } ? U : T> {\n  // @ts-ignore We know what we are doing\n  return m != null && typeof m.then === 'function' ? Promise.resolve(m).then(getDefaultOrElse) : getDefaultOrElse(m);\n}\n","import { type FileOptions, file, fileSync } from './file.js';\n\nexport type JSONValue = null | number | string | boolean | JSONValue[] | { [key: string]: JSONValue };\n\nexport interface JSONOption<V = JSONValue> {\n  /**\n   * File path\n   */\n  readonly path: string;\n  /**\n   * File target state\n   */\n  readonly state: 'present' | 'absent';\n  /**\n   * File content mapping function\n   *\n   * @param content\n   */\n  readonly update?: ((content: V | undefined) => V | undefined) | undefined;\n  /**\n   * File encoding\n   */\n  readonly encoding?: BufferEncoding;\n}\n\nfunction toFileOption<Value>({ update, ...otherOptions }: JSONOption<Value>): FileOptions {\n  return {\n    ...otherOptions,\n\n    update:\n      update == null\n        ? update\n        : (content) => {\n            const jsonValue = content === '' ? undefined : (JSON.parse(content) as Value);\n\n            return JSON.stringify(update(jsonValue));\n          },\n  };\n}\n\n/**\n * Ensure file is present/absent asynchronously with content value initialized or modified with `update`\n *\n * @param options\n */\nexport async function json<Value>(options: JSONOption<Value>): Promise<void> {\n  return file(toFileOption(options));\n}\n\n/**\n * Ensure file is present/absent synchronously with content value initialized or modified with `update`\n *\n * @param options\n */\nexport function jsonSync<Value>(options: JSONOption<Value>): void {\n  return fileSync(toFileOption(options));\n}\n","import type { LanguageId } from './LanguageId.js';\n\nfunction escapeRegExp(value: string) {\n  // eslint-disable-next-line unicorn/prefer-string-raw\n  return value.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nexport namespace Project {\n  /**\n   * A type of a file extension\n   */\n  export type Extension = `.${string}`;\n\n  /**\n   * Object hash of all well-known file extension category to file extensions mapping\n   */\n  export type ExtensionRegistry = { [K in LanguageId]: readonly Extension[] };\n\n  /**\n   * Supported ECMA version\n   *\n   * @example\n   * ```ts\n   * Project.ecmaVersion() // 2022\n   * ```\n   */\n  export function ecmaVersion() {\n    return 2022 as const;\n  }\n\n  const registry: ExtensionRegistry = {\n    css: ['.css'],\n    graphql: ['.gql', '.graphql'],\n    javascript: ['.js', '.cjs', '.mjs'],\n    javascriptreact: ['.jsx'],\n    jpeg: ['.jpg', '.jpeg'],\n    json: ['.json'],\n    jsonc: ['.jsonc'],\n    less: ['.less'],\n    markdown: ['.markdown', '.mdown', '.mkd', '.md'],\n    sass: ['.sass'],\n    scss: ['.scss'],\n    typescript: ['.ts', '.cts', '.mts'],\n    typescriptreact: ['.tsx'],\n    vue: ['.vue'],\n    yaml: ['.yaml', '.yml'],\n  };\n\n  /**\n   * Return a list of extensions\n   *\n   * @example\n   * ```ts\n   * Project.queryExtensions(['javascript']); // ['.js', '.cjs', ...]\n   * Project.queryExtensions(['typescript', 'typescriptreact']); // ['.ts', '.mts', ..., '.tsx']\n   * ```\n   *\n   * @param languages\n   */\n  export function queryExtensions(languages: LanguageId[]): readonly Extension[] {\n    return languages\n      .reduce<Extension[]>((previousValue, currentValue) =>\n        // eslint-disable-next-line unicorn/prefer-spread\n        previousValue.concat(registry[currentValue] ?? ([] as Extension[])), [])\n      // eslint-disable-next-line unicorn/no-array-sort\n      .sort();\n  }\n\n  /**\n   * Supported file extensions\n   *\n   * @example\n   * ```ts\n   * Project.sourceExtensions() // ['.ts', '.js', ...]\n   * ```\n   */\n  export function sourceExtensions() {\n    return queryExtensions(['javascript', 'javascriptreact', 'typescript', 'typescriptreact']);\n  }\n\n  const RESOURCE_EXTENSIONS: readonly Extension[] = Object.freeze([\n    '.gif',\n    '.png',\n    '.svg',\n    ...queryExtensions(['css', 'graphql', 'jpeg', 'less', 'sass', 'sass', 'yaml']),\n  ]);\n\n  /**\n   * Resource file extensions\n   *\n   * @example\n   * ```ts\n   * Project.resourceExtensions() // ['.css', '.sass', ...]\n   * ```\n   */\n  export function resourceExtensions() {\n    return RESOURCE_EXTENSIONS;\n  }\n\n  const IGNORED = Object.freeze([\n    'node_modules/',\n    'build/',\n    'cjs/',\n    'coverage/',\n    'dist/',\n    'dts/',\n    'esm/',\n    'lib/',\n    'mjs/',\n    'umd/',\n  ]);\n\n  /**\n   * Files and folders to always ignore\n   *\n   * @example\n   * ```ts\n   * IGNORED // ['node_modules/', 'build/', ...]\n   * ```\n   */\n  export function ignored() {\n    return IGNORED;\n  }\n\n  /**\n   * Return a RegExp that will match any list of extensions\n   *\n   * @param extensions\n   * @example\n   * ```ts\n   * Project.extensionsToMatcher(['.js', '.ts']) // RegExp = /(\\.js|\\.ts)$/\n   * ```\n   */\n  export function extensionsToMatcher(extensions: readonly Extension[]): RegExp {\n    return new RegExp(`(${extensions.map(escapeRegExp).join('|')})$`);\n  }\n\n  /**\n   * Return a glob matcher that will match any list of extensions\n   *\n   * @param extensions\n   * @example\n   * ```ts\n   * Project.extensionsToGlob(['.js', '.ts']) // '*.+(js|ts)'\n   * ```\n   */\n  export function extensionsToGlob(extensions: readonly Extension[]): string {\n    return `*.+(${extensions.map((_) => _.replace(/^\\./, '')).join('|')})`;\n  }\n}\n","/**\n * Project common scripts\n */\nexport const ProjectScript = {\n  Build: 'build',\n  Clean: 'clean',\n  CodeAnalysis: 'code-analysis',\n  Coverage: 'coverage',\n  Develop: 'develop',\n  Docs: 'docs',\n  Format: 'format',\n  Install: 'install',\n  Lint: 'lint',\n  Prepare: 'prepare',\n  Release: 'release',\n  Rescue: 'rescue',\n  Spellcheck: 'spellcheck',\n  Test: 'test',\n  Validate: 'validate',\n} as const;\nexport type ProjectScript = (typeof ProjectScript)[keyof typeof ProjectScript];\n","import { spawn, spawnSync } from 'node:child_process';\n\nexport interface ExecOptions {\n  /**\n   * Current working directory\n   */\n  cwd?: string;\n  /**\n   * Stdio options\n   */\n  stdio?: 'inherit' | 'pipe' | 'ignore';\n}\n\n/**\n * Runs a command in a shell and returns a promise that resolves with an object\n * containing the stdout and stderr strings.\n *\n * @param command - The command to run\n * @param args - The arguments to pass to the command\n * @param options\n * @returns A promise that resolves with an object like `{ stdout: string, stderr: string }`\n */\nexport function execSync(\n  command: string,\n  args: ReadonlyArray<string>,\n  options?: ExecOptions,\n): { stdout: string; stderr: string } {\n  const result = spawnSync(command, args, { ...options });\n  const encoding = 'utf8';\n\n  return { stdout: result.stdout.toString(encoding), stderr: result.stderr.toString(encoding) };\n}\n\n/**\n * Runs a command in a shell and returns a promise that resolves with an object\n * containing the stdout and stderr strings.\n *\n * @param command - The command to run\n * @param args - The arguments to pass to the command\n * @param options\n * @returns A promise that resolves with an object containing the stdout and stderr strings\n */\nexport async function exec(\n  command: string,\n  args: ReadonlyArray<string>,\n  options?: ExecOptions,\n): Promise<{ stdout: string; stderr: string }> {\n  return new Promise((resolve, reject) => {\n    const encoding = 'utf8';\n    const child = spawn(command, args, { ...options });\n    let stdout = '';\n    let stderr = '';\n\n    // Capture the stdout and stderr streams\n    if (child.stdout != null) {\n      child.stdout.on('data', (data) => {\n        stdout += data.toString(encoding);\n      });\n    }\n    if (child.stderr != null) {\n      child.stderr.on('data', (data) => {\n        stderr += data.toString(encoding);\n      });\n    }\n    // Handle process exit\n    child.on('close', (_code) => {\n      resolve({ stdout, stderr });\n    });\n\n    // Handle errors\n    child.on('error', reject);\n  });\n}\n","import { exec, execSync } from './exec.js';\n\nexport interface YarnConfigOptions {\n  /**\n   * Configuration key\n   */\n  readonly key: string;\n\n  /**\n   * Option target state\n   */\n  readonly state: 'present' | 'absent';\n\n  /**\n   * File content mapping function\n   *\n   * @param content\n   */\n  readonly update?: ((content: string) => string | undefined) | undefined;\n}\n\n/**\n * Synchronous version of {@link yarnConfig}\n *\n * @param options\n * @example\n * yarnConfigSync({\n *   key: 'nodeLinker',\n *   state: 'present',\n *   update: (content) => content.replace('node-modules', 'hoisted'),\n * })\n */\nexport function yarnConfigSync(options: YarnConfigOptions) {\n  const { key, state, update } = options;\n  if (state === 'present') {\n    const { stdout } = execSync('yarn', ['config', 'get', String(key)]);\n    execSync('yarn', ['config', 'set', String(key), `${update == null ? '' : update(stdout)}`]);\n  } else {\n    execSync('yarn', ['config', 'unset']);\n  }\n}\n\n/**\n * Set/Unset yarn configuration value\n *\n * @param options\n * @example\n * await yarnConfig({\n *   key: 'nodeLinker',\n *   state: 'present',\n *   update: (content) => content.replace('node-modules', 'hoisted'),\n * })\n */\nexport async function yarnConfig(options: YarnConfigOptions): Promise<void> {\n  const { key, state, update } = options;\n  if (state === 'present') {\n    const { stdout } = await exec('yarn', ['config', 'get', String(key)]);\n    await exec('yarn', ['config', 'set', String(key), `${update == null ? '' : update(stdout)}`]);\n  } else {\n    await exec('yarn', ['config', 'unset']);\n  }\n}\n","import { exec, execSync } from './exec.js';\n\nexport type YarnVersionKind = 'berry' | 'classic';\n\nexport interface YarnVersionOptions {\n  /**\n   * Option target state\n   */\n  readonly state: 'present' | 'absent';\n\n  /**\n   * Version mapping function\n   *\n   * @param content\n   */\n  readonly update?: (() => YarnVersionKind | undefined) | undefined;\n}\n\n/**\n * Synchronous version of {@link yarnVersion}\n *\n * @param options\n * @example\n * yarnVersionSync({\n *   state: 'present',\n *   update: () => 'berry', // or 'classic'\n * })\n */\nexport function yarnVersionSync(options: YarnVersionOptions) {\n  const { state, update } = options;\n  if (state === 'present') {\n    execSync('yarn', ['set', 'version', `${update == null ? 'berry' : update()}`]);\n  } else {\n    // TODO: remove yarn.lock\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * Set/Unset yarn configuration value\n *\n * @param options\n * @example\n * await yarnVersion({\n *   state: 'present',\n *   update: () => 'berry', // or 'classic'\n * })\n */\nexport async function yarnVersion(options: YarnVersionOptions): Promise<void> {\n  const { state, update } = options;\n  if (state === 'present') {\n    await exec('yarn', ['set', 'version', `${update == null ? 'berry' : update()}`]);\n  } else {\n    // TODO: remove yarn.lock\n    throw new Error('Not implemented');\n  }\n}\n"],"mappings":"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"}