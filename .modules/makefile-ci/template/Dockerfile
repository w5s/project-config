# syntax = docker/dockerfile:1@sha256:93bfd3b68c109427185cd78b4779fc82b484b0b7618e36d0f104d4d801e66d25

#==================================================================================================
#                                         ┓ ┏┏━┏┓
#                                         ┃┃┃┗┓┗┓
#                                         ┗┻┛┗┛┗┛
#
#                                 W5S Docker file
#
#             🔒⚠️ DO NOT EDIT this file manually. This file should be the same between projects
#
#==================================================================================================
#
# 📄 Files :
#
# / (root)
# ├─ app/
# │  ├─ .container/
# │  │  ├─ build ← Container build script
# │  │  ├─ install ← Container dependency installer script
# │  │  ├─ post-deploy ← Post deploy hook (run migration, etc)
# │  │  ├─ start ← Container start script
# │  ├─ Dockerfile ← Multi-stage Dockerfile
# │  ├─ Aptfile ← Debian packages installed on server
# │  ├─ Aptfile.dev ← Debian packages installed to build (not present on server)
# │  ├─ compose-dev.yaml ← Docker compose used for local debug build & run
# │  ├─ compose.yaml ← Docker compose used local release build & run (not used on servers)
# ├─ start ← Generated by Docker build (not in git)
#
#
# ⚙️ Environment variables (.env, docker run --env {{MYVAR2=foo}})
#   - ENVIRONMENT : (ex: staging|production) Generic environment name
#   - RAILS_ENV : (default: $ENVIRONMENT) Rails environment name
#   - NODE_ENV : (default: $ENVIRONMENT) NodeJS environment name
#   - PORT : (default: 3000) default http server port used
#   - BUILD_TYPE : (readonly, debug|release) Define if the container is run in debug mode (for development) or for release (final container published on servers)
#
#
# 🔧 Build Args (docker build --build-args {{ARG1=foo}} --build-args {{ARG2=bar}}) :
#
#   - APT_FILE_MANIFEST: Manifest file used to install dependencies (option, default 'Aptfile')
#   - APT_FILE_DEV_MANIFEST: Manifest file used to install dev dependencies (option, default 'Aptfile.dev')
#   - RUBY_VERSION: ruby version (ex: '3.2.1')
#   - NODEJS_VERSION: nodejs version (ex: '20.0.0')
#   - BUNDLER_VERSION: bundle version (optional, default 2.4.22)
#   - INSTALL_COMMAND: (optional, default '.container/install')
#   - BUILD_COMMAND: (optional, default '.container/build')
#   - START_COMMAND: (optional, default '.container/start')
#   - APP_PATH: (optional, default '/app') Path where the app is installed in the container
#
#
# 💽 Targets (docker build --target {{TARGET}}) :
#
# 'dev-envs' :
#   ✓ Usage: only local development
#   ✓ Build: debug
#     - Files are writable
#     - .container/install, .container/build and .container/start is run when container starts
#     - Procfile.dev is used for startup
# 'builder' :
#   ✓ Usage: only for CI
#   ✓ Build: release
#     - Everything like 'dev-envs'
#     - All dependencies (npm, bundle) are installed
# 'runner' :
#   ✓ Usage: only for production
#   ✓ Build: release
#     - Files are read only
#     - .container/install is run during container build step
#     - .container/build is run during container build step
#     - .container/start is run during container start step
#     - Procfile is used for startup
#

ARG FROM_IMAGE=ubuntu:22.04@sha256:1b8d8ff4777f36f19bfe73ee4df61e3a0b789caeff29caa019539ec7c9a57f95

# Core dependencies (required for asdf)
ARG APT_CORE_DEPENDENCIES="\
  build-essential \
  ca-certificates \
  curl \
  git \
  libffi-dev \
  libssl-dev \
  libyaml-dev \
  zlib1g-dev \
  patch \
  pkg-config \
  wget \
  "
# Packages used at runtime (available on final image)
ARG APT_DEPENDENCIES="\
  curl \
  ca-certificates \
  # Libraries
  libffi7 \
  libffi8 \
  libjpeg8 \
  liblzma5  \
  libncurses5 \
  libpng16-16 \
  libpq5 \
  libreadline8 \
  libsqlite3-0 \
  libssl3 \
  libtiff5 \
  libxml2 \
  libxslt1.1 \
  libyaml-0.2 \
  shared-mime-info \
  tzdata \
  zlib1g \
  "
ARG APT_FILE_MANIFEST=Aptfile
ARG APT_DEV_DEPENDENCIES="\
  # Libraries
  libffi-dev \
  libjpeg-dev \
  liblzma-dev \
  libncurses-dev \
  libpng-dev \
  libpq-dev \
  libreadline-dev \
  libsqlite3-dev \
  libssl-dev \
  libtiff-dev \
  libxml2-dev \
  libxslt1-dev \
  libyaml-dev \
  zlib1g-dev \
  "
ARG APT_FILE_DEV_MANIFEST=Aptfile.dev

# Make sure RUBY_VERSION matches the Ruby version in .tool-versions and Gemfile
ARG ASDF_DIR=/opt/asdf

# Application installation folder
ARG APP_PATH="/app"
ARG APP_BUILD_TOOLS_PATH=/root/.bin

# Application installation folder
ARG INSTALL_COMMAND="./.container/install"
ARG BUILD_COMMAND="./.container/build"
ARG START_COMMAND="./.container/start"

#======================================================================================================================
FROM --platform=$TARGETPLATFORM ${FROM_IMAGE} as base

SHELL ["/bin/bash", "-euo", "pipefail", "-c"]

# Configure as non interactive
ARG DEBIAN_FRONTEND=noninteractive
ARG APP_PATH
ARG APP_BUILD_TOOLS_PATH
ARG ASDF_DIR

# Build type (debug|release)
# - debug : everything is run in watch mode
# - release : everything is built as "production mode"
ARG BUILD_TYPE=release

# Common environment variable

# Generic environment
ENV ENVIRONMENT=${ENVIRONMENT}
ENV RAILS_ENV=${RAILS_ENV:-$ENVIRONMENT}
ENV NODE_ENV=${NODE_ENV:-$ENVIRONMENT}

# ASDF installation directory
ENV ASDF_DIR=${ASDF_DIR}
ENV ASDF_DATA_DIR=${ASDF_DIR}
# Generated script that will launch (and build for dev mode) the application
ENV APP_ENTRYPOINT="/start"
# Name of the current user
ENV APP_USER="app"
# Path to vendor bundle
ENV BUNDLE_PATH="/usr/local/bundle"
# ENV BUNDLE_PATH="${APP_PATH}/vendor/bundle"
# ENV BUNDLE_CACHE_PATH="/var/cache/bundle"

# App lives here
RUN mkdir -p "${APP_PATH}" \
 && mkdir -p "${APP_BUILD_TOOLS_PATH}"
WORKDIR ${APP_PATH}

# ASDF
ENV PATH="${ASDF_DIR}/shims:${ASDF_DIR}/bin:${PATH}"

# Create and configure user
RUN useradd $APP_USER --create-home --shell /bin/bash \
  && echo '! test -f ${ASDF_DIR}/asdf.sh || source ${ASDF_DIR}/asdf.sh' >> $HOME/.bashrc \
  && echo '! test -f ${ASDF_DIR}/asdf.sh || source ${ASDF_DIR}/asdf.sh' >> $HOME/.profile

# Run SetupCommand [optional]
COPY SetupCommand* ./
RUN ! test -f SetupCommand || while read -r cmd; do eval "$cmd"; done < SetupCommand


ENV PATH="${APP_BUILD_TOOLS_PATH}:${PATH}"
# Create container-def-bin
RUN \
touch "${APP_BUILD_TOOLS_PATH}/container-def-bin" \
&& chmod +x "${APP_BUILD_TOOLS_PATH}/container-def-bin" \
&& cat > "${APP_BUILD_TOOLS_PATH}/container-def-bin" <<EOF
#!/usr/bin/env bash
touch "${APP_BUILD_TOOLS_PATH}/\$1" \
  && chmod +x "${APP_BUILD_TOOLS_PATH}/\$1" \
  && cp /dev/stdin "${APP_BUILD_TOOLS_PATH}/\$1"
EOF

RUN \
# container-apt-install
container-def-bin "container-apt-install" <<EOF
#!/usr/bin/env bash

apt-get update -yqq \
  && apt-get install -yqq --no-install-recommends \$* \
  && rm -rf /var/lib/apt/lists/*
EOF

RUN \
# container-apt-install-manifest
container-def-bin "container-apt-install-manifest" <<EOF
#!/usr/bin/env bash

# Installation
if [ -f \$1 ]; then \
  awk '/^:repo:deb/ { print "echo \"deb "\$2" "\$3" "\$4" "\$5"\" >> /etc/apt/sources.list.d/\${1}.list" }' \$1 | sh \
  && apt-get update -yqq \
  && awk '!/^#/ && !/^:repo:deb/ { print }' \$1 | xargs apt-get install -yqq --no-install-recommends; \
else
  echo "Error: APT manifest file '\$1' was not found" >&2; exit 2;
fi \
&& rm -rf /var/lib/apt/lists/*
EOF

# Initialize empty entrypoint script
RUN \
  mkdir -p $(dirname "/start") \
  && touch "/start" \
  && chmod +x "/start"

#======================================================================================================================
FROM base as cache-apt-runner

# Packages used at build step (not available on final image)
ARG APT_DEPENDENCIES
ARG APT_FILE_MANIFEST

# Install Build dependencies
RUN container-apt-install ${APT_DEPENDENCIES}

# Install all from Aptfile [optional]
COPY ${APT_FILE_MANIFEST}* ./
RUN container-apt-install-manifest "${APT_FILE_MANIFEST}"

#======================================================================================================================
FROM cache-apt-runner as cache-asdf

# Packages used at build step (not available on final image)
ARG APT_CORE_DEPENDENCIES
ARG APT_DEV_DEPENDENCIES
ARG ASDF_VERSION=0.13.1
ARG RUBY_VERSION
ARG NODEJS_VERSION
ARG BUNDLER_VERSION=2.4.22

# Install Build dependencies
RUN container-apt-install ${APT_CORE_DEPENDENCIES}

# Install ASDF
RUN mkdir -p $(dirname ${ASDF_DIR}) \
  && git clone https://github.com/asdf-vm/asdf.git ${ASDF_DIR} --branch "v${ASDF_VERSION}"

# Install All tools
COPY .tool-versions* ./
# Install Ruby
RUN asdf plugin add ruby \
  && asdf install ruby

# Install Bundler
RUN gem install bundler --no-document -v "${BUNDLER_VERSION}"
# Install foreman for startup
RUN gem install --no-document foreman

# Install NodeJS
RUN asdf plugin add nodejs \
  && asdf install nodejs

#======================================================================================================================
FROM cache-asdf as cache-apt-builder

# Packages used at build step (not available on final image)
# ARG APT_DEV_DEPENDENCIES
ARG APT_FILE_DEV_MANIFEST

# Install Build dependencies
RUN container-apt-install ${APT_DEV_DEPENDENCIES}

# Install Docker tools (cli, buildx, compose)
COPY --from=gloursdocker/docker@sha256:756a5712056c43dc5028b0dc8bfd9dbd171fce27f8c6b24ae5f5839ff7f2af1f / /

# Install all from Aptfile.dev [optional]
COPY ${APT_FILE_DEV_MANIFEST}* ./
RUN container-apt-install-manifest "${APT_FILE_DEV_MANIFEST}"

#======================================================================================================================
FROM cache-apt-builder as dev-envs

# Build args
ARG BUILD_COMMAND
ARG INSTALL_COMMAND
ARG START_COMMAND
ARG BUILD_TYPE=debug

# Environment variables
ENV BUILD_TYPE=${BUILD_TYPE}

# Install All tools
COPY .tool-versions* ./

# Copy .container/
COPY ./.container/ ./.container/

# Build startup script
RUN \
  cat > "/start" <<EOF
#!/usr/bin/env bash
cd ${APP_PATH}
${INSTALL_COMMAND}
${BUILD_COMMAND}
${START_COMMAND} "\$@"
EOF

CMD ["sh", "-c", "/start"]

#======================================================================================================================
FROM dev-envs as builder

# Build args
ARG BUILD_COMMAND
ARG INSTALL_COMMAND
# Override build type
ARG BUILD_TYPE=release

# Build environment (production)
ENV CI="1"
ENV BUNDLE_DEPLOYMENT="1"

# Install dependencies
COPY .tool-versions* ./
COPY Gemfile* ./
COPY package*.json yarn*.lock .yarnrc* ./
COPY .yarn/ ./.yarn

RUN \
  # Run custom build command
  ${INSTALL_COMMAND} \
  # Cleanup
  && rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git \
  && rm -rf /var/lib/apt/lists/*

# Copy application code
COPY . .
RUN \
  # Run custom build command
  ${BUILD_COMMAND}

# Final stage for app image
FROM cache-apt-runner AS runner

# Run args
ARG APP_PATH
ARG START_COMMAND
ARG APT_DEPENDENCIES
ARG APT_FILE_MANIFEST
ARG BUILD_TYPE

# Environment
ENV APP_PATH=${APP_PATH}
ENV BUILD_TYPE=${BUILD_TYPE}

# Build startup script
RUN cat > "/start" <<EOF
#!/usr/bin/env bash
cd ${APP_PATH}
${START_COMMAND} "\$@"
EOF

# Install ASDF
COPY --from=cache-asdf ${ASDF_DIR} ${ASDF_DIR}
# Copy built artifacts: gems, application
COPY --from=builder ${BUNDLE_PATH} ${BUNDLE_PATH}
COPY --from=builder ${APP_PATH} ${APP_PATH}

# Run and own only the runtime files as a non-root user for security
RUN for writable_directory in db log storage tmp config; \
  do \
    [ ! -d $writable_directory ] || chown -R $APP_USER:$APP_USER "$writable_directory"; \
  done

USER $APP_USER:$APP_USER

# Entrypoint prepares the database.
EXPOSE 3000
ENTRYPOINT ["/start"]
